#include <iostream>
#include <queue>
#include <stack>
#include <vector>

using namespace std;

// Структура для представления ребра графа
struct Edge {
    int begin; // Начальная вершина ребра
    int end;   // Конечная вершина ребра
};

// Класс Node представляет вершину графа
class Node {
public:
    int id;     // Уникальный идентификатор вершины
    int state;  // Состояние вершины: 0 = не посещена, 1 = обнаружена, 2 = посещена

    // Конструктор для инициализации вершины с заданным id
    Node(int id) : id(id), state(0) {}
};

// Класс Graph для представления и работы с графом
class Graph {
private:
    // Матрица смежности для хранения связей между вершинами графа
    int adjacencyMatrix[7][7] = {
        { 0, 1, 0, 0, 0, 0, 0 },
        { 0, 0, 1, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 1, 0, 0 },
        { 0, 0, 0, 0, 0, 1, 0 },
        { 0, 0, 0, 1, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 1 },
        { 0, 0, 0, 0, 0, 0, 0 }
    };
    
    vector<Node> nodes;   // Вектор для хранения всех вершин графа
    stack<Edge> edges;    // Стек для хранения рёбер пути

public:
    // Конструктор графа, инициализирует вершины
    Graph() {
        for (int i = 0; i < 7; i++) {
            nodes.push_back(Node(i)); // Добавляем вершины с идентификаторами от 0 до 6
        }
    }

    // Метод для обхода графа в ширину (Breadth-First Search)
    void BFS(int start, int target) {
        queue<int> Queue; // Очередь для хранения вершин для обработки
        Queue.push(start); // Добавляем начальную вершину в очередь
        nodes[start].state = 1; // Помечаем начальную вершину как обнаруженную

        cout << "Обход в ширину, начиная с вершины " << start + 1 << ":\n";

        // Процесс обхода пока очередь не пуста
        while (!Queue.empty()) {
            int nodeID = Queue.front(); // Берем вершину из начала очереди
            Queue.pop(); // Убираем вершину из очереди
            nodes[nodeID].state = 2; // Помечаем вершину как посещенную
            cout << nodeID + 1 << endl; // Выводим идентификатор посещаемой вершины

            // Проверяем смежные вершины
            for (int j = 0; j < 7; j++) {
                // Если есть ребро и вершина не посещена
                if (adjacencyMatrix[nodeID][j] == 1 && nodes[j].state == 0) {
                    Queue.push(j); // Добавляем вершину в очередь
                    nodes[j].state = 1; // Отмечаем как обнаруженную
                    edges.push({ nodeID, j }); // Сохраняем ребро для восстановления пути
                    if (j == target) break; // Если достигли целевой вершины, прерываем цикл
                }
            }
        }
    }

    // Метод для вывода пути от начальной вершины до целевой
    void printPath(int target) {
        cout << "Путь до вершины " << target + 1 << ":\n" << target + 1; // Начинаем с целевой вершины
        while (!edges.empty()) {
            Edge e = edges.top(); // Берем верхнее ребро из стека
            edges.pop(); // Убираем его из стека
            if (e.end == target) { // Если конечная вершина совпадает с целевой
                target = e.begin; // Переходим к начальной вершине
                cout << " <- " << target + 1; // Выводим её идентификатор
            }
        }
        cout << endl; // Конец вывода пути
    }
};

int main() {
    system("chcp 1251"); // Устанавливаем кодировку консоли для отображения русских символов
    system("cls"); // Очищаем экран консоли

    Graph graph; // Создаем объект графа
    int req; // Переменная для хранения номера целевой вершины
    cout << "Введите номер целевой вершины (1-7): ";
    cin >> req; // Считываем номер целевой вершины от пользователя
    req--; // Приводим номер к индексу (0-6)

    graph.BFS(0, req); // Запускаем обход в ширину с вершины 0 до целевой
    graph.printPath(req); // Выводим путь до целевой вершины

    cin.get(); // Ожидание ввода перед завершением программы
    cin.get(); // Дополнительный ввод для предотвращения мгновенного закрытия консоли
    return 0; // Завершение программы
}
